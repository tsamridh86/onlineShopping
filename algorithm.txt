This doc is for the #nettra :P project, i have assumed you know SQL,PHP, so i haven't explained baby details here.

I know you wont read all this, use Ctrl + F to find the topic you want to know about lol.
hit Ctrl + F then type in orderPage to read about it, reading all this is too much work.

Some minor things(1):
after using a select query, i have retreived the values in fetch_assoc() mode:
eg. $que = "select * from users";
	$result = $connect->query($que);
	while($res = $result->fetch_assoc())

the select commands brings data from the server to the client in a specific format, when using the fetch_assoc() method,
it brings in all the details as the attribute name = array Name ;

sql output :
userId  |  userName | autho
1		|	lol		|	A
2		|	hi 		|	C

then
$res['userId'] = {1,2}
$res['userName'] = {lol,hi}
$res['autho'] = {A,C}
 ^ 		^		^	^
dumy   attr     1st 2nd
var    name     itr itr

the 1st itr means that 1st iteration of the loop, similarly, if there 5 elements, the dummy variable will reach the 
5th row in the 5th iteration of the loop.

Keep in mind that you cannot jump to your result, or reset the dummy varaible to the desired position.
Suppose, you are in the 3rd iteration of the loop & you want to access the 1st element again, this is not possible.
Similarly, if you only want the 3rd row only, then you have to use the loop 3 times to reach that point.

there are other methods of retrieving data too :
here is some help : http://www.w3schools.com/php/php_mysql_select.asp


Some other minor things(2):
when using a form,
<form method = "post" action = "somepage.php" enctype = "multiform/form-data">
	<input name = "lol" type = "text">
	<input type = "file" name = "pic">
	<select name = "t">
		<option value = 1 ></option>
		<option value = 2 ></option>
	</select>	
	<input type = "submit">

A form in php is used to move from one page to another along with some data in it.
	a form has method i.e., either get or post,
	get will send all the data to other page, in such a way that all parameters are visible in the url.
	this is useful for searching querys as the user does not has to return to the previous page to search,
	simply modifying the url is enough.
	post method will send data to other page, hidden to everyone, this is typically secure & maybe used in forms,
	that have sensitive data like passwords , images etc.

	If, method get is used, then the information is available on the other page as $_GET['inputName'];
	& if method = post then, $_POST['inputName']

	action = "" , is the destination page where the input data needs to be sent.

	enctype = "multiform/form-data" is only required when you have to send an image to the other page.
	Images & any other type of files uploaded are available insides $_FILES['fieldName']['tmp_name'] (here tmp_name is syntax)

	every input / select option must have a name to it, for it to be retreived on the other side.

	for the above example,
	let's assume the user typed in a name, inserted an image & then selected the 2nd option & hit the submit button.
	Then all of this data is available in the somepage.php as 
	$_POST['lol'] , $_FILES['pics']['tmp_name'] , $_POST['t']
		^				^								^
 inserted name 		uploaded image 					 = 2 (because the value = 2 in the 2nd option)


some minor things(3):
-- use of sessions:
sessions :  A session is a way to store information (in variables) to be used across multiple pages. 
	This is stored on the server rather than on the client machine,
	whenever we use, session_start(), we are able to create & use any amount of session variables.
 Here, sessions are started immediately in most of the pages & 
 	$_SESSION['userName'] is used to store the name of user, ( generally used to display welcome userName at the top right)
 	$_SESSION['userType'] is used to check the authority of the user at the beginning of the page, for example at sellerpage
 	if a customer forcefully types in url, sellerPage.php then the user will be redirected away to the appropiate page.
 	$_SESSION['userId'] is used generally to fill up the table data, (this is very effective as whenever we insert into a 
 	table with the an active session, we can know who inserted the item or placed the order).

1. NLI.php
	to make sure a user is logged out, we need to destroy it's sessions, however, it cannot be directly destroyed.
	Hence:
	session_start(); <-- Activates all user session & variables
	session_destroy(); <--Destroys session data & variables 
& since now all the session variables have been destroyed, it equivalent of being logged out.


2.config.php

	we create a connection to the mysql database using the command ,
	$connect = mysqli("serverName","userName","password");

	one may also connect as : $connect = mysqli("serverName","userName","password","databaseName");
	but we have assumed that the database does not exists, so we use the first command.
	
	here, $connect stores the data about the database connection.

	$dbstart = "create database if not exists shops;";
	$connect->query($dbstart);
	mysqli_select_db($connect , "shops");

	creates the database if it does not exists & will NOT replace an existing database.
	it executes this query & connect onto the shops database,
	table is not created directly because all the tables must lie inside a database.

	then the three tables are created, 
	users, orders, items,

	!IMPORTANT
	this page does not close the connection of database by 
	$connect->close();
	this is so that whenever we use require 'config.php';
	we can use $connect as a connection to the database & hence we do not require to create a new variable everytime,
	however, always remember close the connection after you are done, because it could cause some errors.


3.loginpage

when entering the loginPage the first time the if condition on line 2 will not work anyway, so directly jump to the form far below in the page. The form is rather simple, you'll understand it

After suitable values have been kept inside the form, it redirects to itself,
now the both the values of the if conditions are satisfied,
since the userName is unique, we search for that person & brings up his/her details (the select command brings up the details)
it checks it with the input given, if correct then
sessions are started,
session variable ( user-defined) userType , userName & userId are created & given appropiate values
(these are later used to insert into tables, check whether the correct users are logged in or not etc.)
then the logged in user is directed to it's appropiate page
otherwise the warning the userName/password does not exists is simply displayed on the screen.

4. SignUp page

	similar to the loginpage, the if conditions will not work when you enter the page the first time, so jump ahead to the form.
After suitable values have been entered to the form, then, it sends the data from the page to itself.

Now, all the if conditions are satisfied,
	on lines, 8 to 10, all the userName from the database are retreived & is checked with the current user input, 
	if a name on the database exists same as the user, then a msg it displayed to rename it.

if the name is unique, then the data obtained from the form in inserted into the database, then, session variables are intialized
then, the user is logged it, each user is directed to it's appropiate page.

5.sellerPage.php
	this page is exclusive to the seller only, if a customer types in sellerpage.php s/he will be redirected to welcome page.php(line 16 & 17)

	the upcoming if condition will not start anyway, so directly move to form below
	the form requires filling up of the data of the items inside it, the form redirects it to this page itself,
	now the if condition that did not work previously, will be activated,
	as soon as the if condition true, 
	
	the image that was previously kept as the input will be uploaded,
	now, the image is NOT stored in the database it is only stored in a location of the server,
	so, we only the save the location of the image in the database, on the actual image itself,
	however, there maybe a chance that there may already exist a file that has the same name as the one being uploaded,
	so, if a file with the same name exists, then,
	substr, breaks the nae of the file, adds a number into it, & then reconcate them again, this way we bypass the problem of same name files.
	This new-renamed file is then moved into the images folder, & it's location along with it's name is stored inside the items table.

	Following the upload, the category will also be concated & saved,
		Although there are 2 seperate inputs, category1 & category2, (but displayed to the user & category & type)
		It is concatenated as category1_category2,
		This is later used for searching in search.php & hence the concatenated result is saved in the database.

	There were 2 submits buttons on the page, depending upon which one was clicked, the type get's determined.

	It is then inserted into the table, now, we don't provide & itemId because it is an auto_increment property, custId is also left as NULL, custId value is set as NULL until some user bids for that item,(also, an item on sale will always have it's type attribute as NULL), then it's status is also by default 'N' & will only be active if & only if, the admin provides approval.

	After the insertion, the user is requested to wait for admin approval for the sale of the item.


	Below that, there is a dropdown menu, if a seller want to delete his approved items.

		using select itemId, itemName from items where sellerId = $_SESSION['userId'] and status = 'Y'
		will give the items sold by that seller only (the user can only be seller because other type of users are redirected away from this page)
		again here fetch_assoc() is used to get the nessecary details in required format.
		the while loop will continually display all the items related in proper format.

		all the items are displayed in the dropdown menu,
		If user chooses one option then, the itemId of that item will be sent to the same page
		& will get deleted by using, "delete from items where itemId = $_POST['itemId']";

	The last div simply shows all the orders that have been requested,
	This is done by using the orders table instead, upon joining the orders table with the items table w.r.t. it's itemId, then
	we can obtain all the details of the item, however, all the names of the users are stored inside the users table, so,
	the users table is also joined into this new table, 
	now, we have combination of 3 tables,

	now, we display the customer name (select userName from users join table where custId = userId)
		the price & the quantity of the item, the grand total is not stored in the database because
		it is a derived attribute & hence storing it on the database is a wastage of space.
	similarly a table of items on bid will be kept on display, showing the latest bidder & the peak price.


6. adminpage.php
	This page just shows stats for the most part. 
	The first few lines are to redirect away any unwanted users that are not admins, then using config.php we connect to the 
	database. The first if condition will only run if the admin has approved of any item in the form below. The approval is 
	simple, when we get a approve click, we send the id of the item in a hidden manner, & then perform:
		update items set status = 'Y' where itemId = $_POST['itemId']
		(also note that this if condition wll not work when we first enter the page).

	line no 31 to 43 are all about extracting each data from all the tables.
	44-48 are used to count the number of rows that we get, so that they can be used to show the stats on the top left of the page
	line 50 - 73 is used to display the stats box, all the data for it comes from the line 44-48,
	also, items on sale was not extracted seperately, because :
		total items = no.of items on sale + no of items on bid.
		Since, we already have 2 values, there is no need to run an extra query for the 3rd one.

	Next section is for the item waiting for approval:
		It is simple to know the unapproved items, they have the status = 'N',
		so, select * from items where status = 'N' does the trick,
		all the values are retrieved & shown inside a div from line 78-116.
		There is a form inside too, the form exists here because, it is used to transfer the itemid (in hidden input) to
		the page itself, so that when someone clicks on approve, the if condition on line 24 is activated &
		approves the item.

	The next section is to display all the approved items on the database:
		Contrary to above, this can be done by, select * from items where status = 'Y';
		Similar div as above is used to display all the approved items form line no 126 to 162.

	The next section is to display all the users in the database:
		query : select * from users.
		Here, the users attributes are shown in table format, hence there is no div inside the while loop on line 165-187

	The final section is for the orders on the database, this requires some joins because :
		orders(itemId,custId, quantity) are the only attribute inside the orders table,
		hence, when we join orders & items table w.r.t. itemId, then we can retrive itemName & sellerId,
		from this joint table, if we join users on it, w.r.t. userId = custId,
		we retrive the name of the customer & for the seller, inside the while loop, we run:
		select * from users where userId = sellerId.

		All of the data obtained from the above queries are displayed in appropiate manner inside a table from line 229 to 253 

7.orderPage.php

	Since, a customer may only place an order, any other user, (usually the ones that are not logged in) are requested to signUp 
	or login before they can proceed any further in the page.
	If, the userType = 'C', (ie customer), all the details of the items are redisplayed on the screen again, for a review,
	also, this data is obtained from search.php or directly from the now trending of the welcomePage.

	From the search page, we are sent the itemId of the item that the user wants to buy,
	then the details of the items can be obtained by the query :

	"select * from items where itemId = "$_GET['itemId'];

	after obtaining the details of the items, we use fetch_assoc() (this time it's used without a while loop because 
	we want to show only one item & only itemID is the primary key, hence only one result can be generated, so why use a loop? lol)

	also the query in line 44 is used to take retrive the name of the seller because, we only have the sellerId in the items table
	hence, we have to show the customers the name of the seller, it's pointless to show them sellerId.

	category was concatenated eariler in sellerPage,
	hence we seperate it out, here, ( _ is the divider that shows that the 2 strings are different)

	--category seperation algorithm:
	len = 0;
	while($row['category'][$len++]!="_");			<-- detects where the _ is in the string
	$cat1 = substr($row['category'],0,$len-1);		<-- chops off the part before the _ , 0 to $len-1(there are 3 parameters here)
	$cat2 = substr($row['category'],$len);			<-- chops off the after after the _ , $len to infinite (there are only 2 parameter in this line, note that)

	after seperating it out, we check whether the item was on a bid, or it was on sale & appropiately change the display.

	Keep in mind the we only send the variables quantity & itemId to the orderComplete page.

		Now, some minor tricks that was used:
		1. an item can either be on sale or on a bid.
		2. if an item is on sale, we send it's quantity & itemId to the orderComplete page.
		3. if am item is on bid, we send it's newPrice & itemId to the orderComplete page.
		4. both quantity & newPrice are input type = number.

			Here, itemId has to be sent in both cases, it is sent away in hidden format, because the customer does not need to 
			know itemId & stuff.

			Since, either quantity or newPrice is sent one at a time, we send only one variable to the other page.
			(ki quantity pathunxau ya newPrice, bekar ma extra variable baunune ko satta euta mai pathae better)

		So, if the item is on sale , we send the quantity as name = quantity to the other page
		& if the item is on bid, we send the newPrice as name = quantity to the other page, hence minimizing the thing.

	after we display it on the screen, there no fancy algorithm here on out, display was adjusted by trail & error.
	
	Note:  --image renaming note
	at line 57, $locs = $row['imgLoc'] was done because at line 59,
	we display the image as :
		echo "<img src = '$locs' height = 500 px width = 500px align = left>";
	Now, this can also be done as :
		echo "<img src = '$row['imgLoc']' height = 500 px width = 500px align = left>";
	instead, but because there is a \' in $row['imgLoc'] it caused a syntax error, hence to fix it, $locs was used as an 
	extra variable.

8.orderComplete
	This starts by verifying whether the customer is still logged in, if not, then it is redirected away.
	Now, we recieved the itemId & the quantity if the item was on sale & we recieved the newPrice named as quantity
	if the item was placed on the bid.

	So, we retireve the data on the item again, & then
		if the item was on sale, then:
		insert the item into the orders table 

		--inserting into orders table.

		orders(orderid , itemId ,   custId,    quantity)
				^			^		  ^	         ^
			automatic    $_POST   $_SESSION    $_POST['quantity']
			increment  ['itemId']	['userType']

		so the query :

		$order = "insert into orders (custId,itemId,quantity) values (".$_SESSION['userId'].",".$_POST['itemId'].",".$_POST['quantity'].");";
		
		explains itself.

	Now, if the item was on a bid, we do not place it inside the orders table at all.
	Firstly, we check whether the input we recieved from the other page, (ie, quantity) has a larger value than that of the previous bid.
		This is acheived by the if condition on line no 52.
	If the newPrice(renamed as quantity for minimization purpose) is greater than the old price then,
	 change it's price in the items table & add the custId to it.
		(adding the custId now, shows the id of the latest bidder, which inturn can be used to retrieve the name).

	This can be done by the update query:
"update items set custId = ".$_SESSION['userId']." , price = ".$_POST['quantity']." where itemId = ".$_POST['itemId'].";";
								^									^										^
							latest bidder						newPrice								item to be updated

	In the end, the data is displayed again, as a reciept formaility thing so that it can be understood that the customer has brought the item.

9. welcomePage

	This the first page of the project, we also assume that the execution of the code begins from here.

	There is a div on the top left, this is for the shop logo. Which is not my problem.

	Beside is a search bar : 
		This search bar is a simple <input type = text name = query > made fancy with a bunch of css.
		Then the magnifying glass beside is also <input type = submit> made fancy with a chunk of css.
		The query typed in this search bar is inside a form that redirects into the search page.

			(To search for search page algorithm : search : --search page algorithm)
		Keep in mind that this search bar can only be used to search the items according to their itemName attribute
		this will not work for other attributes.

	Below it is navigational bar, they are all buttons in a unordered list & made horizontal by css property:
		display: inline-block;
		the buttons also look more fancy because of CSS.
	The dropdown menu is another ul inside the li of the main ul.
		This however is hidden by using the css property : display : hidden, & when we hover over it, we change it's 
		settings to display : block;
	Each button is named as cat & has the value like men_sunglasses or women_eyeglasses etc that are sent to the search page.
	The last column is an exception to this as it searches for items that are either on bid or on sale so hence, it's name 
	has to be type, so that it can be searched acc to type attribute.

	Below this is a banner, set up by ever conventional trial & error.
	Then, there comes the now trending tab:

	--now trending algorithm
		Now Trending items are the items are most bought by the customers. Hence to find such an item, we refer to the 
		orders table as they have the quantity purchased property.

	to find the total quantity: we use sum(quantity), 
	now, we need to find total quantity of the item brought : so , sum(quantity) group by itemId
	to see the 3 most trending things, we sort it in descending order : sum(quantity) group by itemId order by sum(quantity) desc

	this explains the query inside the bracket in line no 116.
	now, we need the details of the item, so we join it with items to retrive all it's details, & we need to sort it again.

	Since, sorting once is better than sorting twice, the order by is removed from the inner query & placed outside.
	The form leads to orderPage because we give the customer the ability to buy the items from the now trending tab itself.

	Note that the sum(quantity) attribute has been renamed to q so that, SQL understands it as a row rather than a function again.

	All of this is displayed in a div using the same method as used in adminPage.

10. search page:
	The search page gets it's queries / filter from welcomePage & search page itself:
		Here, we first create the sidebar that shows various filters: (line 40 to 60 is explained litter later)

	we extract all the shapes that are in the database by select distinct shape from items.
		(distinct is used so that if 2 items have the same shape, the same shape is repeated in screen)
	display it,
	similarly, we display color, brand , seller in a similar manner, the category & type is fixed because there are only 
	2 or 3 possible options, so we dont use a for loop.
	All of these is in a form redirected to this page itself, they are also kept in get format so that it appears on the 
	URL & it can be modified without needing to unnessicarily reload the page.

	Now, for the search algorithm in line 40 

	--search algorithm:
	we only have to display the items that are approved by the admin, so 
	firstly, we type in :
	select * from items where status = 'Y'

	now, there could be other search filters like color, shape etc.
	So,

	extend the query as :

	$que = "select * from items where status = 'Y' and ";

	if the user has searched by item name: ( from the welcomePage)
	if(!empty($_GET['query']))
		$que = $que."itemName like '%".$_GET['query']."%' and ";

		add one more condition to search similar names, by simply concating it.

	if the shape radio button has been clicked then, extend it further by adding the condition
	if(!empty($_GET['shape']))
		$que = $que."shape = '".$_GET['shape']."' and ";

	similarly for color
	if(!empty($_GET['color']))
		$que = $que."color = '".$_GET['color']."' and ";

	this category comes from the side bar, ie men, women, kids
	if(!empty($_GET['category1']))
		$que = $que."category like '".$_GET['category1']."%' and ";

	this comes form the side bar, ie eyeglasses & sunglasses
	if(!empty($_GET['category2']))
		$que = $que."category like '%".$_GET['category2']."' and ";

	this comes from the navigational bar from the welcomePage
	if(!empty($_GET['cat']))
		$que = $que."category = '".$_GET['cat']."' and ";

	this comes from the sidebar 
	if(!empty($_GET['seller']))
		$que = $que."sellerid = ".$_GET['seller']." and ";

	this comes from the navigational bar & the side bar (both of the inputs have the name = type so no conflict)
	if(!empty($_GET['type']))
		$que = $que."type = '".$_GET['type']."' and ";

	this comes from the sidebar
	if(!empty($_GET['brand']))
		$que = $que."brand = '".$_GET['brand']."' and ";


	Now, any of the if conditions can run, or none of them may run,
		if their conditions are satisfied, then the search query is extended otherwise it remains the same,

	eg, 1 if the customers searches as color = black & sellerid = 5 then the query would be :

	select * from items where color = 'black' and sellerId = 5;

	eg 2 if customer searches for eyeglasses then:

	select * from items where category like '%eyeglasses' 

	eg 3 if the customer searches for the black round sunglasses for men  on sale then :

	select * from items where color = 'black' and shape 'round' and category like 'men%' and category like '%sunglasses' and type = 'S'

	now, we wrench off the un-needed and at the end, then
	The generated query retreives the relevant information & then displays it to the user.