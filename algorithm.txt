This doc is for the #nettra :P project, i have assumed you know SQL,PHP, so i haven't explained baby details here.

I know you wont read all this, use Ctrl + F to find the topic you want to know about lol.
hit Ctrl + F then type in orderPage to read about it, reading all this is too much work.

Some minor things(1):
after using a select query, i have retreived the values in fetch_assoc() mode:
eg. $que = "select * from users";
	$result = $connect->query($que);
	while($res = $result->fetch_assoc())

the select commands brings data from the server to the client in a specific format, when using the fetch_assoc() method,
it brings in all the details as the attribute name = array Name ;

sql output :
userId  |  userName | autho
1		|	lol		|	A
2		|	hi 		|	C

then
$res['userId'] = {1,2}
$res['userName'] = {lol,hi}
$res['autho'] = {A,C}
 ^ 		^		^	^
dumy   attr     1st 2nd
var    name     itr itr

there are other methods of retrieving data too :
here is some help : http://www.w3schools.com/php/php_mysql_select.asp


Some other minor things(2):
when using a form,
<form method = "get" action = "somepage.html" enctype = "multiform/form-data">
	<input name = "lol" type = "text">
	<input type = "file" name = "pic">
	<select name = "t">
		<option value = 1 ></option>
		<option value = 2 ></option>
	</select>	
	<input type = "submit">

A form in php is used to move from one page to another along with some data in it.
	a form has method i.e., either get or post,
	get will send all the data to other page, in such a way that all parameters are visible in the url.
	this is useful for searching querys as the user does not has to return to the previous page to search,
	simply modifying the url is enough.
	post method will send data to other page, hidden to everyone, this is typically secure & maybe used in forms,
	that have sensitive data like passwords , images etc.

	If, method get is used, then the information is available on the other page as $_GET['inputName'];
	& if method = post then, $_POST['inputName']

	action = "" , is the destination page where the input data needs to be sent.

	enctype = "multiform/form-data" is only required when you have to send an image to the other page.
	Images & any other type of files uploaded are available insides $_FILES['fieldName']['tmp_name'] (here tmp_name is syntax)

	every input / select option must have a name to it, for it to be retreived on the other side.

	for the above example,
	after 

1. NLI.php
	to make sure a user is logged out, we need to destroy it's sessions, however, it cannot be directly destroyed.
	Hence:
	session_start(); <-- Activates all user session & variables
	session_destroy(); <--Destroys session data & variables 
& since now all the session variables have been destroyed, it equivalent of being logged out.


2.config.php

	we create a connection to the mysql database using the command ,
	$connect = mysqli("serverName","userName","password");

	one may also connect as : $connect = mysqli("serverName","userName","password","databaseName");
	but we have assumed that the database does not exists, so we use the first command.
	
	here, $connect stores the data about the database connection.

	$dbstart = "create database if not exists shops;";
	$connect->query($dbstart);
	mysqli_select_db($connect , "shops");

	creates the database if it does not exists & will NOT replace an existing database.
	it executes this query & connect onto the shops database,
	table is not created directly because all the tables must lie inside a database.

	then the three tables are created, 
	users, orders, items,

	!IMPORTANT
	this page does not close the connection of database by 
	$connect->close();
	this is so that whenever we use require 'config.php';
	we can use $connect as a connection to the database & hence we do not require to create a new variable everytime,
	however, always remember close the connection after you are done, because it could cause some errors.


3.loginpage

when entering the loginPage the first time the if condition will not work anyway, so directly jump to the form far below in the page. The form is rather simple, you'll understand it

After suitable values have been kept inside the form, it redirects to itself,
now the both the values of the if conditions are satisfied,
since the userName is unique, is search for that person & brings up his/her details (the select command brings up the details)
it checks it with the input given, if correct then
sessions are started,
session variable ( user-defined) userType , userName & userId are created & given appropiate values
(these are later used to insert into tables, check whether the correct users are logged in or not etc.)
then the logged in user is directed to it's appropiate page
otherwise the warning the userName/password does not exists is simply displayed on the screen.

4. SignUp page

	similar to the loginpage, the if conditions will not work when you enter the page the first time, so jump ahead to the form.
After suitable values have been entered to the form, then, it sends the data from the page to itself.

Now, all the if conditions are satisfied,
	on lines, 8 to 10, all the userName from the database are retreived & is checked with the current user input, 
	if a name on the database exists same as the user, then a msg it displayed to rename it.

if the name is unique, then the data obtained from the form in inserted into the database, then, session variables are intialized
then, the user is logged it, each user is directed to it's appropiate page.

5.sellerPage.php
	this page is exclusive to the seller only, if a customer types in sellerpage.php s/he will be redirected to welcome page.php(line 16 & 17)

	the upcoming if condition will not start anyway, so directly move to form below
	the form requires filling up of the data of the items inside it, the form redirects it to this page itself,
	now the if condition that did not work previously, will be activated,
	as soon as the if condition true, 
	
	the image that was previously kept as the input will be uploaded,
	now, the image is NOT stored in the database it is only stored in a location of the server,
	so, we only the save the location of the image in the database, on the actual image itself,
	however, there maybe a chance that there may already exist a file that has the same name as the one being uploaded,
	so, if a file with the same name exists, then,
	substr, breaks the nae of the file, adds a number into it, & then reconcate them again, this way we bypass the problem of same name files.
	This new-renamed file is then moved into the images folder, & it's location along with it's name is stored inside the items table.

	Following the upload, the category will also be concated & saved,
		Although there are 2 seperate inputs, category1 & category2, (but displayed to the user & category & type)
		It is concatenated as category1_category2,
		This is later used for searching in search.php & hence the concatenated result is saved in the database.

	There were 2 submits buttons on the page, depending upon which one was clicked, the type get's determined.

	It is then inserted into the table, now, we don't provide & itemId because it is an auto_increment property, custId is also left as NULL, custId value is set as NULL until some user bids for that item,(also, an item on sale will always have it's type attribute as NULL), then it's status is also by default 'N' & will only be active if & only if, the admin provides approval.

	After the insertion, the user is requested to wait for admin approval for the sale of the item.


	Below that, there is a dropdown menu, if a seller want to delete his approved items.

		using select itemId, itemName from items where sellerId = $_SESSION['userId'] and status = 'Y'
		will give the items sold by that seller only (the user can only be seller because other type of users are redirected away from this page)
		again here fetch_assoc() is used to get the nessecary details in required format.
		the while loop will continually display all the items related in proper format.

		all the items are displayed in the dropdown menu,
		If user chooses one option then, the itemId of that item will be sent to the same page
		& will get deleted by using, "delete from items where itemId = $_POST['itemId']";

	The last div simply shows all the orders that have been requested,
	This is done by using the orders table instead, upon joining the orders table with the items table w.r.t. it's itemId, then
	we can obtain all the details of the item, however, all the names of the users are stored inside the users table, so,
	the users table is also joined into this new table, 
	now, we have combination of 3 tables,

	now, we display the customer name (select userName from users join table where custId = userId)
		the price & the quantity of the item, the grand total is not stored in the database because
		it is a derived attribute & hence storing it on the database is a wastage of space.
	similarly a table of items on bid will be kept on display, showing the latest bidder & the peak price.


6. adminpage.php
	This page just shows stats for the most part. 
	The first few lines are to redirect away any unwanted users that are not admins, then using config.php we connect to the 
	database. The first if condition will only run if the admin has approved of any item in the form below. The approval is 
	simple, when we get a approve click, we send the id of the item in a hidden manner, & then perform:
		update items set status = 'Y' where itemId = $_POST['itemId']
		(also note that this if condition wll not work when we first enter the page).

	line no 31 to 43 are all about extracting each data from all the tables.
	44-48 are used to count the number of rows that we get, so that they can be used to show the stats on the top left of the page
	line 50 - 73 is used to display the stats box, all the data for it comes from the line 44-48,
	also, items on sale was not extracted seperately, because :
		total items = no.of items on sale + no of items on bid.
		Since, we already have 2 values, there is no need to run an extra query for the 3rd one.

	Next section is for the item waiting for approval:
		It is simple to know the unapproved items, they have the status = 'N',
		so, select * from items where status = 'N' does the trick,
		all the values are retrieved & shown inside a div from line 78-116.
		There is a form inside too, the form exists here because, it is used to transfer the itemid (in hidden input) to
		the page itself, so that when someone clicks on approve, the if condition on line 24 is activated &
		approves the item.

	The next section is to display all the approved items on the database:
		Contrary to above, this can be done by, select * from items where status = 'Y';
		Similar div as above is used to display all the approved items form line no 126 to 162.

	The next section is to display all the users in the database:
		query : select * from users.
		Here, the users attributes are shown in table format, hence there is no div inside the while loop on line 165-187

	The final section is for the orders on the database, this requires some joins because :
		orders(itemId,custId, quantity) are the only attribute inside the orders table,
		hence, when we join orders & items table w.r.t. itemId, then we can retrive itemName & sellerId,
		from this joint table, if we join users on it, w.r.t. userId = custId,
		we retrive the name of the customer & for the seller, inside the while loop, we run:
		select * from users where userId = sellerId.

		All of the data obtained from the above queries are displayed in appropiate manner inside a table from line 229 to 253 

7.orderPage.php

	Since, a customer may only place an order, any other user, (usually the ones that are not logged in) are requested to signUp 
	or login before they can proceed any further in the page.
	If, the userType = 'C', (ie customer), all the details of the items are redisplayed on the screen again, for a review,
	also, this data is obtained from search.php or directly from the now trending of the welcomePage.

	From the search page, we are sent the itemId of the item that the user wants to buy,
	then the details of the items can be obtained by the query :

	"select * from items where itemId = "$_GET['itemId'];

	after obtaining the details of the items, we use fetch_assoc() (this time it's used without a while loop because 
	we want to show only one item & only itemID is the primary key, hence only one result can be generated, so why use a loop? lol)

	also the query in line 44 is used to take retrive the name of the seller because, we only have the sellerId in the items table
	hence, we have to show the customers the name of the seller, it's pointless to show them sellerId.

	category was concatenated eariler in sellerPage,
	hence we seperate it out, here, ( _ is the divider that shows that the 2 strings are different)

	--category seperation algorithm:
	len = 0;
	while($row['category'][$len++]!="_");			<-- detects where the _ is in the string
	$cat1 = substr($row['category'],0,$len-1);		<-- chops off the part before the _ , 0 to $len-1(there are 3 parameters here)
	$cat2 = substr($row['category'],$len);			<-- chops off the after after the _ , $len to infinite (there are only 2 parameter in this line, note that)

	after seperating it out, we check whether the item was on a bid, or it was on sale & appropiately change the display.

	Keep in mind the we only send the variables quantity & itemId to the orderComplete page.

		Now, some minor tricks that was used:
		1. an item can either be on sale or on a bid.
		2. if an item is on sale, we send it's quantity & itemId to the orderComplete page.
		3. if am item is on bid, we send it's newPrice & itemId to the orderComplete page.
		4. both quantity & newPrice are input type = number.

			Here, itemId has to be sent in both cases, it is sent away in hidden format, because the customer does not need to 
			know itemId & stuff.

			Since, either quantity or newPrice is sent one at a time, we send only one variable to the other page.
			(ki quantity pathunxau ya newPrice, bekar ma extra variable baunune ko satta euta mai pathae better)

		So, if the item is on sale , we send the quantity as name = quantity to the other page
		& if the item is on bid, we send the newPrice as name = quantity to the other page, hence minimizing the thing.

	after we display it on the screen, there no fancy algorithm here on out, display was adjusted by trail & error.
	
	Note:  --image renaming note
	at line 57, $locs = $row['imgLoc'] was done because at line 59,
	we display the image as :
		echo "<img src = '$locs' height = 500 px width = 500px align = left>";
	Now, this can also be done as :
		echo "<img src = '$row['imgLoc']' height = 500 px width = 500px align = left>";
	instead, but because there is a \' in $row['imgLoc'] it caused a syntax error, hence to fix it, $locs was used as an 
	extra variable.

8.orderComplete
	This starts by verifying whether the customer is still logged in, if not, then it is redirected away.
	Now, we recieved the itemId & the quantity if the item was on sale & we recieved the newPrice named as quantity
	if the item was placed on the bid.

	So, we retireve the data on the item again, & then
		if the item was on sale, then:
		insert the item into the orders table 

		--inserting into orders table.

		orders(orderid , itemId ,   custId,    quantity)
				^			^		  ^	         ^
			automatic    $_POST   $_SESSION    $_POST['quantity']
			increment  ['itemId']	['userType']

		so the query :

		$order = "insert into orders (custId,itemId,quantity) values (".$_SESSION['userId'].",".$_POST['itemId'].",".$_POST['quantity'].");";
		
		explains itself.

	Now, if the item was on a bid, we do not place it inside the orders table at all.
	Firstly, we check whether the input we recieved from the other page, (ie, quantity) has a larger value than that of the previous bid.
		This is acheived by the if condition on line no 52.
	If the newPrice(renamed as quantity for minimization purpose) is greater than the old price then,
	 change it's price in the items table & add the custId to it.
		(adding the custId now, shows the id of the latest bidder, which inturn can be used to retrieve the name).

	This can be done by the update query:
"update items set custId = ".$_SESSION['userId']." , price = ".$_POST['quantity']." where itemId = ".$_POST['itemId'].";";
								^									^										^
							latest bidder						newPrice								item to be updated

	In the end, the data is displayed again, as a reciept formaility thing so that it can be understood that the customer has brought the item.

